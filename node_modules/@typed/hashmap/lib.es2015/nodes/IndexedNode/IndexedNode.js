import { empty } from '../EmptyNode';
import { SIZE, MAX_INDEX_NODE, hashFragment, toBitmap, bitmapToIndex, remove, insert, replace, } from '../../common';
import { toArrayNode } from './toArrayNode';
var IndexedNode = (function () {
    function IndexedNode(mask, children) {
        this.type = 3 /* INDEX */;
        this.mask = mask;
        this.children = children;
    }
    IndexedNode.prototype.modify = function (shift, get, hash, key, size) {
        var _a = this, mask = _a.mask, children = _a.children;
        var fragment = hashFragment(shift, hash);
        var bit = toBitmap(fragment);
        var index = bitmapToIndex(mask, bit);
        var exists = Boolean(mask & bit);
        var current = exists ? children[index] : empty();
        var child = current.modify(shift + SIZE, get, hash, key, size);
        if (current === child)
            return this;
        if (exists && child.type === 0 /* EMPTY */) {
            var bitmap = mask & ~bit;
            if (!bitmap)
                return empty();
            return children.length <= 2 && isLeaf(children[index ^ 1])
                ? children[index ^ 1]
                : new IndexedNode(bitmap, remove(index, children));
        }
        if (!exists && child.type !== 0 /* EMPTY */) {
            return children.length >= MAX_INDEX_NODE
                ? toArrayNode(fragment, child, mask, children)
                : new IndexedNode(mask | bit, insert(index, child, children));
        }
        return new IndexedNode(mask, replace(index, child, children));
    };
    return IndexedNode;
}());
export { IndexedNode };
function isLeaf(node) {
    var type = node.type;
    return type === 0 /* EMPTY */ ||
        type === 1 /* LEAF */ ||
        type === 2 /* COLLISION */;
}
//# sourceMappingURL=IndexedNode.js.map